[ { "title": "Abstract Factory 패턴", "url": "/posts/00016-Abstract-Factory-%ED%8C%A8%ED%84%B4/", "categories": "정보처리기사, 디자인패턴", "tags": "정보처리기사, 디자인패턴", "date": "2022-03-25 13:45:00 +0900", "snippet": "구체적인 클래스에 의존하지 않고 연관, 의존적인 객체의 조합을 만드는 인터페이스를 제공구체적인 구현은 Concrete Product 클래스에서 이루어짐동일 주제의 다른 팩토리를 묶는다.클래스 다이어그램 [^출처]소스코드public interface IButton { void Paint();}public interface IGUIFactory { IBtton CreateButton();}public class WinButton extends IButton { public void Paint() { // Paint the button Windows style }}public class OSXButton extends IButton { public void Paint() { // Paint the button OSX style }}public class WinFactory implements IGUIFactory { @Override protected IButton CreateButton() { return new WinButton(); }}public class OSXFactory implements IGUIFactory { @Override protected IButton CreateButton() { return new OSXButton(); }}public class AbsFactoryExample { public static void main(String args[]) { String style = DesignConfig.STYLE; IGUIFactory factory; if(style == FormStyle.WIN){ factory = new WinFactory(); }else if(style == FormStyle.OSX){ factory = new OSXFactory(); }else{ throws new NotImplementedException(); } Button button = factory.CreateButton(); button.paint(); }}" }, { "title": "Factory Method 패턴", "url": "/posts/00015-Factory-Method-%ED%8C%A8%ED%84%B4/", "categories": "정보처리기사, 디자인패턴", "tags": "정보처리기사, 디자인패턴", "date": "2022-03-25 11:57:00 +0900", "snippet": "상위 클래스에서 객체를 생성하는 인터페이스 정의 (만드는 방법만 결정)하위 클래스에서 인스턴스 생성 (실제 함수를 오버라이딩 하여 구현)클래스 다이어그램 [^출처]소스코드public abstract class Room { abstract void connect(Room room);}public class MagicRoom extends Room { public void connect(Room room) {}}public class OrdinaryRoom extends Room { public void connect(Room room);}public abstract class MazeGame { private final List&lt;Room&gt; rooms = new ArrayList&lt;&gt;(); public MazeGame() { Room room1 = makeRoom(); Room room2 = makeRoom(); room1.connect(room2); rooms.add(room1); rooms.add(room2); } abstract protected Room makeRoom();}public class MagicMazeGame extends MazeGame { @Override protected Room makeRoom() { return new MagicRoom(); }}public class OrdinaryMazeRoom extends MazeGame { @Override protected Room makeRoom() { return new OrdinaryRoom(); }}public class FactoryExample { public static void main(String args[]) { // Room1과 Room2가 연결되는 구조는 동일하나 // 생성할 때 OrdinaryMazeRoom이 되는지 // MagicMazeRoom이 되는지 결정된다. MazeGame ordinaryGame = new OrdinaryMazeGame(); MazeGame magicGame = new MagicMazeGame(); }}" }, { "title": "Prototype 패턴", "url": "/posts/00014-Prototype-%ED%8C%A8%ED%84%B4/", "categories": "정보처리기사, 디자인패턴", "tags": "정보처리기사, 디자인패턴", "date": "2022-03-25 11:39:00 +0900", "snippet": "일반적인 원형을 만든 뒤, 그것을 복사하여 필요한 부분만 수정하여 사용객체의 원형을 제공하는 인스턴스에서 객체의 타입이 결정객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴기존 객체를 복제함으로 생성클래스 다이어그램 [^출처]소스코드// Prototype Classpublic class Cookie implements Cloneable { public Object clone() { try { Cookie copy = (Cookie)super.clone(); return copy; } catch(CloneNotSupportedException e){ e.printStackTrace(); return null; } }}// Concreate Prototype to Clonepublic class CoconutCookie extends Cookie {}// Client Classpublic class CookieMachine { private Cookie cookie; public CookieMachine(Cookie cookie) { this.cookie = cookie; } public Cookie makeCookie() { return (Cookie)cookie.clone(); } public Object clone() {}}public class PrototypeExample { public static void main(String args[]) { Cookie tempCookie = null; Cookie prot = new CoconutCookie(); CookieMachine machine = new CookieMachine(prot); // 여기에서 타입이 결정됨 for (int i = 0; i &lt; 100; i++){ tempCookie = machine.makeCookie(); } }}" }, { "title": "Builder 패턴", "url": "/posts/00013-Builder-%ED%8C%A8%ED%84%B4/", "categories": "정보처리기사, 디자인패턴", "tags": "정보처리기사, 디자인패턴", "date": "2022-03-25 11:04:00 +0900", "snippet": "복잡한 인스턴스를 조립하여 만드는 구조복합 객체를 생성할 때 객체를 생성하는 방법과 구현하는 방법을 분리동일 생성 절차로 다른 표현 결과를 만들 수 있음클래스 다이어그램 [^출처]소스코드// Product@Setterclass Pizza { private String dough = \"\"; private String sauce = \"\"; private String topping = \"\";}// Abstract Builder@Getterabstrac class PizzaBuilder { protected Pizza pizza; public void createNewPizzaProduct() { pizza = new Pizza(); } public abstract void buildDough(); public abstract void buildSauce(); public abstract void buildTopping();}// ConcreteBuilderclass SpicyPizzaBuilder extends PizzaBuilder { public void buildDough() { pizza.setDough(\"pan baked\"); } public void buildSauce() { pizza.setSauce(\"hot\"); } public void buildTopping() { pizza.setTopping(\"pepperoni+salami\"); }}// ConcreteBuilderclass PepperoniPizzaBuilder extends PizzaBuilder { public void buildDough() { pizza.setDough(\"cross\"); } public void buildSauce() { pizza.setSauce(\"mild\"); } public void buildTopping() { pizza.setTopping(\"pepperoni\"); }}// Directorclass Cook { private PizzaBuilder pizzaBuilder; public void setPizzaBuilder(PizzaBuilder pizzaBuilder) { this.pizzaBuilder = pizzaBuilder; } public Pizza getPizza() { return pizzaBuilder.getPizza(); } public void constructPizza() { pizzaBuilder.createNewPizzaProduct(); pizzaBuilder.buildDough(); pizzaBuilder.buildSauce(); pizzaBuilder.buildTopping(); }}public class BuilderExample { public static void main(String[] agrs) { Cook cook = new Cook(); PizzaBuilder pepperoniPizzaBuilder = new PepperoniPizzaBuilder(); PizzaBuilder spicyPizzaBuilder = new SpicyPizzaBuilder(); cook.setPizzaBuilder(pepperoniPizzaBuilder); cook.constructPizza(); Pizza pizza = cook.getPizza(); }}" }, { "title": "디자인 패턴 기초", "url": "/posts/00012-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/", "categories": "정보처리기사, 디자인패턴", "tags": "정보처리기사, 디자인패턴", "date": "2022-03-25 11:02:00 +0900", "snippet": "디자인 패턴의 개념소프트웨어 설계에서 공통으로 발생하는 문제 해결을 위하여 설계 방법을 정리한 패턴.개발의 효율성, 유지보수성, 운용성이 높아지며 최적화에 도움이 됨디자인 패턴의 종류 생성 패턴 Builder Prototype Factory Method Abstract Factory Singleton 구조패턴 Bridge Decorate Facade Flyweight Proxy Composite Adapter Mediator Interpreter 행위패턴 Iterator Template Method Observer State Visitor Command Strategy Memento Chain of Responsibility " }, { "title": "현행시스템 파악", "url": "/posts/00011-%ED%98%84%ED%96%89%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%8C%8C%EC%95%85/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-25 10:10:00 +0900", "snippet": " 절차 1단계 구성 / 기능 / 인터페이스 파악 2단계 아키텍쳐 및 소프트웨어 구성 파악 3단계 하드웨어 및 네트워크 구성 파악 소프트웨어 아키텍쳐여러가지 소프트웨어 구성요소의 외부에 드러나는 특성구성요소 간의 관계를 표현하는 시스템의 구조나 구조체소프트웨어 아키텍쳐 패턴 유형 설명 계층화 패턴 (Layered Pattern) 시스템을 계층으로 구분하여 구성하위 모듈은 추상화를 제공각 계층은 상위 계층에 서비스 제공계층화 패턴은 서로 마주보는 계층끼리 상호작용 클라이언트 - 서버 패턴 (Client - Server Pattern) 하나의 서버, 다수의 클라이언트사용자가 클라이언트로 요청시 서버가 서비스 제공서버는 클라이언트 요청을 항시 대기 파이프 - 필터 패턴 (Pipe - Filter Pattern) 데이터 스트림을 생성하고 처리하는 시스템에서 사용서스 시스템이 입력을 처리하고 다음 서브 시스템으로 전달필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장이 용이 브로커 패턴 (Broker Pattern) 분산 시스템에서 사용원격 서비스 실행을 통해 상호작용브로커 컴포넌트는 컴포넌트 간의 통신을 조정서버는 자신의 기능을 브로커에 넘겨줌클라이언트가 요청 시 브로커는 적합한 서비스로 라다이렉션함 모델 - 뷰 - 컨트롤러 패턴 (Model View Controller Pattern) 대화형 애플리케이션을 모델, 뷰, 컨트롤러로 구조화각 부분이 별도의 컴포넌트로 분리, 서로 영향을 받지 않음코드의 효율적인 재사용 가능대화형 애플리케이션 구축에 적합 MVC 종류 설명 모델 (Model) 핵심 기능과 데이터 보관 뷰 (View) 사용자에게 정보 표시 컨트롤러 (Controller) 사용자에게 요청을 입력 받아 처리 " }, { "title": "일정관리 모델", "url": "/posts/00010-%EC%9D%BC%EC%A0%95%EA%B4%80%EB%A6%AC-%EB%AA%A8%EB%8D%B8/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-25 09:57:00 +0900", "snippet": " 종류 모델 설명 주 공정법 (CPM : Critical Path Method) 여러 작업의 수행순서가 얽혀있는 프로젝트의 일정을 계산모든 자원 제약사항을 배제한 상태로 Node간 연결을 통해 공정을 계산하는 Activity 표기법 PERT (Program Evaluation and Review Technique) 일의 순서를 계회적으로 정리하기 위한 수렴기법비관치, 중간치 낙관치 3점 추정방식으로 일정 관리 중요 연쇄 프로젝트 관리(CCPM; Critical Chain Project Managment) 주 공정 연쇄법으로 자원 제약사항을 고려하여 일정을 작성 주 공정 : Critical Path : 프로젝트의 시작에서 종료까지 가장 긴 시간이 걸리는 경로 " }, { "title": "Spring Security 로그아웃 Filter", "url": "/posts/Spring-Security-%EB%A1%9C%EA%B7%B8%EC%95%84%EC%9B%83-%EC%84%A4%EC%A0%95/", "categories": "Spring Security", "tags": "Spring Security", "date": "2022-03-25 00:00:00 +0900", "snippet": "로그아웃 Filter@Configuration@EnableWebSecurity@RequiredArgsConstructorpublic class SecurityConfig extends WebSecurityConfiguraterAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.logout() .logoutUrl(\"/logout\") .logoutSuccessUrl(\"/\") .logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\")) .invalidateHttpSession(true) .deleteCookies(\"SESSION_ID\") .addLogoutHandler(handler) .logoutSuccessHandler(handler); }}" }, { "title": "로그인 Controller 구현", "url": "/posts/Spring-Security-Controller-%EA%B5%AC%ED%98%84/", "categories": "Spring Security", "tags": "Spring Security", "date": "2022-03-25 00:00:00 +0900", "snippet": "Controller 구현 Account DTO 구현 @Getter@Setter@NoArgsConstructor@Builderpublic class AccountDto { private Long id; private String username; private String password; public Account toEntity() { return Account.builder() .id(id) .username(username) .password(password) .build; }} @Controller@AllArgsConstructorpublic class AccountController { private AccountService accountService; public static String SESSION_ID = \"SESSION_ID\" @GetMapping(\"/\") public String index(){ return \"index\"; } @GetMapping(\"/signup\") public String signup(Model model){ model.addAttribute(\"account\", new AccountDto()); return \"/signup\" } @PostMapping(\"/signup\") public String signup(AccountDto accountDto) { AccountService.signUp(accountDto); return \"redirect:/\"; } @GetMapping(\"/login\") public String login() { return \"/loginForm\"; } @PostMapping(\"/login\") public String login(@ModelAttribute @Validated LoginForm loginForm, BindingResult bindingResult @RequestParam(defaultValue = \"/\") String redirectURL) { if (bindingResult.hasErrors()){ return \"/loginForm\"; } Account account = AccountService.login(loginForm.getUsername(), loginForm.getPassword()); if (account == null){ bindingResult.reject(\"loginFailed\", \"아이디 또는 비밀번호가 일치하지 않습니다.\"); return \"/loginForm\"; } HttpSession session = request.getSession(); session.setAttribute(SESSION_ID, account); return \"redirect:\" + redirectURL; } @PostMapping(\"/logout\") public String logout(HttpServletRequest request) { HttpSession session = request.getSession(false); if(session != null) { session.invalidate(); } return \"redirect:/\"; }}" }, { "title": "비용산정 모형", "url": "/posts/00009-%EB%B9%84%EC%9A%A9%EC%82%B0%EC%A0%95-%EB%AA%A8%ED%98%95/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 투입자원, 소요시간을 파악하여 실행 가능한 계획을 수립하기 위해 비용을 산정종류 분류 설명 종류 하향식 산정방법 경험이 많은 전문가에게 의뢰여러 전문가와 조정자를 통해 산정 전문가 판단델파이 기법 상향식 산정방법 세부적인 요구사항과 기능에 따라 산정 코드 라인 수 (Loc)Man MonthCOCOMO 모형푸트남 모형기능점수 (FP) 모형 델파이 기법 (Delphi Method) : 전문가의 경험적 지식을 통해 문제 해결 및 미래예측LoC (Lines of Code) 모형 각 기능의 코드 라인 수의 낙관치, 중간치, 비관치를 측정하여 예측치를 구하고 비용을 산정 측정이 쉽고 이해가 쉽다. 예측치를 이용하여 생산성, 노력, 개발 기간 비용 산정\\[예측치 = \\frac{ｏ+4ｍ+ｐ}{6} (o=낙관치, m:중간치, p:비관치)\\] 낙관치 : 가장 적게 측정된 코드 라인 수 중간치 : 측정된 모든 코드 라인 수의 평균 비관치 : 가장 많이 측정된 코드 라인 수Man Month 모형 한 사람이 1개월 동안 할 수 있는 일의 양을 기준으로 비용을 산정 Man Month : (Loc) / (월간 생산성) 프로젝트 기간 : (Man Month) / (프로젝트 인력)COCOMO (Constructive COst MOdel) 모형 Bohem이 제안한 모형 프로그램 규모에 따라 비용을 산정 필요한 노력(Man Month)으로 산정 비용 견적의 강도 분석 및 유연성이 높다COCOMO 소프트웨어 개발 유형 유형 설명 조직형 (Organic Mode) 기관 내부에서 개발된 중/소규모 소프트웨어일괄 자료 처리나 과학 기술 계산용, 비즈니스 자료 처리 개발에 적용5만(50KDSI) 라인 이하의 소프트웨어를 개발하는 유형 반 분리형 (Semi-Detached Mode) 단순형과 임베디드형의 중간트랜잭션 처리 시스템, DB 관리 시스템, 컴파일러, 인터프리터 유틸30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형 임베디드형 (Embedded Mode) 초대형 규모의 트랜잭션 처리 시스템이나 운영체제, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적용30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형 푸트남(Putnam) 모형 개발주기의 단계별로 요구할 인력의 분포를 가정하는 방식 생명주기 예측 모형이라고 함 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 함기능점수 (FP; Function Point) 모형 요구 기능을 증가시키는 인자별로 가중치 부여 요인별 가중치를 합산하여 청 점수를 계산하여 비용 산정\\[기능점수(FP)=총기능점수\\times[0.65+(0.1\\times총 영향도)]\\] 경험을 바탕으로 단순, 보통, 복잡 정도에 따라 가중치 부여" }, { "title": "객체지향 분석 방법론", "url": "/posts/00008-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95%EB%A1%A0/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 사용자의 요구사항을 분석하여 클래스(객체), 속성과 연산, 관계를 정의하여 모델링 종류 만든 사람 설명 OOSE (Object Oriented Software Engineering) 야콥슨 유스케이스에 의한 접근분석, 설계, 구현 단계로 구성기능적 요구사항 중심 OMT (Object Modeling Technology) 럼바우 그래픽 표기법을 이용객체 모델링→동적모델링→기능 모델링 순서 OOD (Object Oriented Design) 부치 설계 문서화를 강조, 다이어그램 중심 개발 분석과 설계의 분리가 불가능분석에 이용된 객체 모델의 설계 시 적용 OMT 명칭 설명 객체 모델링 (Object Modeling) 정보 모델링 (Information Modeling) 이라고 함 시스템에서 요구하는 객체를 찾고 ER 다이어그램을 만드는 과정 동적 모델링 (Dynamic Modeling) 시간의 흐름에 따른 객체 사이의 제어 흐름, 동작 순서를 표현 상태 다이어그램을 이용하여 표현 기능 모델링 (Functional Modeling) 프로세스들의 자료 흐름을 중심으로 처리 과정 표현 자료 흐름도(DFD를 활용하여 표현) " }, { "title": "애자일 - 린 (LEAN)", "url": "/posts/00007-%EC%95%A0%EC%9E%90%EC%9D%BC-LEAN/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 도요타의 린 시스템 품질기법을 개발 프로세스에 적용 낭비 요소를 제거하여 품질 향상 JIT (Just In Time), 칸반 (Kanban) 보드 사용 원칙 낭비제거 품질 내재화 지식 창출 늦은 확정 빠른 인도 사람 존중 전체 최적화 " }, { "title": "애자일 - 스크럼 (SCRUM)", "url": "/posts/00006-%EC%95%A0%EC%9E%90%EC%9D%BC-SCRUM/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 방법론 주요 개념 설명 백로그 (Backlog) 제품과 프로젝트에 대한 요구사항 스프린트 (Sprint) 2~4주 주기로 개발 진행, 개발 품질 향상 스크럼 미팅 (Scrum Metting) 15분 미팅으로 To-Do List 수립Daliy Meeting 이라고도 함 스프린트 회고 (Sprint Retrospective) 스프린트 주기를 돌아보며 규칙 준수 여부, 개선점 확인스프린트가 끝난뒤나 일정 주기로 시행 번 다운 차트 (Burn Down Chart) 남아있는 백로그 대비 시간을 그래픽으로 표현한 차트백로그는 수직축에 위치, 시간은 수평축에 위치 " }, { "title": "애자일 - XP (Extream Programming)", "url": "/posts/00005-%EC%95%A0%EC%9E%90%EC%9D%BC-xp/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 의사소통 개선과 즉각적 피드백 1~3주의 반복 (Iteration) 개발주기가치 용기 (Courage) 단순성 (Simplicity) 의사소통 (Communication) 피드백 (Feedback) 존중 (Respect)기본원리 기본원리 설명 짝 프로그래밍 (Pair Programming) 개발자 둘이서 짝으로 코딩 공동 소유 코드 (Collective Ownership) 시스템에 있는 코드는 언제, 누구나 수정 가능 지속적인 통합 (CI; Continuous Integration) 매일 여러번씩 소프트웨어를 통합, 빌드 계획 세우기 (Planning Process) 고객이 요구하는 비즈니스 가치를 정의, 개발자가 필요한 것과 지연 요소를 알려줘야 함 작은 릴리즈 (Small Release) 작은 시스템을 먼저 만들고 짧은 단위로 업데이트 메타포어 (Metaphor) 공통된 이름 체계와 시스템 서술서로 고객과 개발자간 의사소통을 원활하게 함 간단한 디자인 (Simple Design) 현재 요구사항에 적합한 가장 단순한 시스템 설계 테스트 기반 개발 (TDD; Test Driven Develop) 프로그램에 대한 테스트를 먼저 수행이 테스트를 통과할 수 있도록 프로그램을 구현 리팩토링 (Refactoring) 기능 변경 없이 중복제거, 단순화를 위해 시스템을 재구성 40시간 작업 (40-Hour Work) 개발자가 피곤으로 실수하지 않도록1주에 40시간 이상 일하지 말아야 한다는 원리 고객 상주 (On Site Customer) 개발자의 질문에 즉각 대답해줄 수 있는 고객을프로젝트에 풀타임으로 상주 코드 표준 (Coding Standard) 효과적인 공동 작업을 위해 코드에 대한 표준을 정의 " }, { "title": "애자일 (Aglie)", "url": "/posts/00004-%EC%95%A0%EC%9E%90%EC%9D%BC/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": "개념 절차보다 사람 중심 변화에 유연, 신속하게 적응 신속 적응형 경랑 개발 방법론 개발 기간이 짧고 신속 폭포수 모형에 대비 개발과 함께 즉시 피드백등장 배경 소프트웨어 개발 환경의 변화 기존 개발 방법론의 한계유형 XP 린 (Lean) 스크럼 (SCRUM)비교 비교대상 애자일 전통적 계획수립 유동적 범위 확정적 범위 업무수행 팀 중심 업무 관리자 주도 개인 단위 업무수행 개발/검증 반복 주기 단위로 개발 검증 분석 설계 구현 테스트 순차 팀관리 업무 몰입, 팀평가 경쟁, 개별 평가 문서화 문서화보다 코드가 중요 상세한 문서화 성공요소 고객 가치 전달 계획 / 일정 준수 유형 XP, 스크럼, 린 폭포수, 프로토타입, 나선형 " }, { "title": "소프트웨어 개발 방법론", "url": "/posts/00003-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EB%B2%95%EB%A1%A0/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-24 00:00:00 +0900", "snippet": " 개발 전 과정에서 지속적으로 사용할수 있는 방법, 절차, 기법 소프트웨어를 하나의 생명체로 간주, 개발 시작부터 사용하지 않는 과정까지의 전 과정을 형상화 한 방법론이다.소프트웨어 방법론 종류구조적 방법론 (Structured Development) 전체 시스템을 기능에 따라 나누어 개발 기능을 통합하는 분할 정복 접근 방식 구조적 프로그래밍 표현을 위해 나씨-슈나이더만 차트 사용나씨-슈나이터만 차트 논리 기술에 중점을 둔 도형 표현 연속, 선택 및 다중 선택, 반복 등의 제어 논리 구조로 표현 복합 조건의 처리를 시각적으로 명확히 식별하는데 적합정보공학 방법론 (Information Engineering Development) 정보시스템 개발에 필요한 관리 절차와 작업 기반을 체계화한 방법론 개발주기를 이용해 대형프로젝트를 수행객체 지향 방법론 (Object-Oriented Development) 객체를 기본 단위로 시스템을 분석 설계 사람이 이해하는 방식으로 시스템에 적용 객체, 클래스, 메시지를 사용컴포넌트 기반 방법론 (CBD; Component Based Development) 컴포넌트를 조립해서 하나의 프로그램을 작성 개발 기간 단축으로 생산성 향상 새로운 기능추가가 쉬움 소프트웨어 재사용 가능애자일 방법론 (Agile Development) 절차보다 사람 중심 변화에 유연, 신속하게 적응하여 효율적 시스템 개발 신속 적응적 경량 개발 방법론 개발 과정의 어려움을 극복하기 위한 방법론제품 계열 방법론 (Product Line Development) 특정 제품에 적용할 공통 기능을 정의하여 개발 임베디드 개발에 유용 영역 공학과 응용 공학으로 구분 이름 내용 영역 공학 영역 분석, 영역 설계, 핵심 자산 구현 응용 공학 제품 요구 분석, 제품설계, 제품 구현 " }, { "title": "Thymeleaf 제어문", "url": "/posts/Thymeleaf-control/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-24 00:00:00 +0900", "snippet": "변수식 HTML```html&lt;!DOCTYPE HTML&gt; ...\t ...- Controller```java@Controllerpublic class Controller{\t@RequestMapping(\"/calc\")\tpublic ModelAndView calc(ModelAndView mav){\t\tmav.setViewName(\"calc\");\t\t\t\tmav.addObject(\"condition\", \"true\");\t\tmav.addObject(\"trueValue\", \"0\");\t\tmav.addObject(\"falseValue\", \"9999\");\t\t\t\treturn mav;\t}} 결과 0 if문&lt;!DOCTYPE HTML&gt;&lt;html&gt; ...\t&lt;p th:if=\"${condition}\" th:text=\"${trueValue}\"&gt;&lt;/p&gt;\t&lt;p th:unless=\"${condition}\" th:text=\"${falseValue}\"&gt;&lt;/p&gt; ...&lt;/html&gt; 결과 0 switch문&lt;!DOCTYPE HTML&gt;&lt;html&gt; ...\t&lt;div th:switch=\"${number}\"&gt;\t\t&lt;p th:case=\"1\" th:text=\"11\"&gt;1&lt;/p&gt;\t\t&lt;p th:case=\"2\" th:text=\"22\"&gt;2&lt;/p&gt;\t\t&lt;p th:case=\"3\" th:text=\"33\"&gt;3&lt;/p&gt;\t\t&lt;p th:case=\"*\"&gt;x&lt;/p&gt;\t&lt;/div&gt; ...&lt;/html&gt; Controller @Controllerpublic class Controller{ @RequestMapping(\"/{number}\") public ModelAndView calc(@PathVariable int number, ModelAndView mav){ mav.setViewName(\"index\");\t mav.addObject(\"number\", number); return mav; }} 결과 (2 입력) 22 결과 (5 입력) x 반복문&lt;!DOCTYPE HTML&gt;&lt;html&gt; ...\t&lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;Name&lt;/td&gt; &lt;td&gt;Nickname&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"obj:${list}\"&gt; \t&lt;td th:text=\"${obj[0]}\"&gt;&lt;/td&gt; &lt;td th:text=\"${obj[1]}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ...&lt;/html&gt; Controller @Controllerpublic class Controller{ @RequestMapping(\"/{user_info}\") public ModelAndView calc(ModelAndView mav){ mav.setViewName(\"user_info\");\t ArrayList&lt;String[]&gt; list = new ArrayList&lt;String[]&gt;(); list.add(new String[] {\"ByeongDong\", \"BD\"}); list.add(new String[] {\"JaeYong\", \"Observer\"});\t\t mav.addObject(\"list\", list); return mav; }} 결과 -------------------------| Name | Nickname || ---------- | -------- || ByeongDong | BD ||------------|----------|| JaeYong | Observer |------------------------- " }, { "title": "Thymeleaf 링크 방식", "url": "/posts/Thymeleaf-basic-4/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-24 00:00:00 +0900", "snippet": "링크 방식 HTML```html&lt;!DOCTYPE HTML&gt; ...\tGo to game list ...- 결과&lt;u&gt;Go to game list&lt;/u&gt;Link 클릭 시https://Base_URL/game/list로 이동```" }, { "title": "Thymeleaf의 객체 변수 방식", "url": "/posts/Thymeleaf-basic-3/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-24 00:00:00 +0900", "snippet": "객체 변수 방식 Controller @Controllerpublic class Controller{ @RequestMapping(\"/\") public String user_info(Model model){ User user = new User(\"asd\", \"123\") model.addAttribute(\"user_info\") return \"user_info\"; }} DTO @RequiredArgsConstructorpublic class User{ @NotBlank private final String id;\t @NotBlank private final String pw;} HTML```html&lt;!DOCTYPE HTML&gt; ...\t ...- 결과asd123```" }, { "title": "Thymeleaf의 메세지 방식", "url": "/posts/Thymeleaf-basic-2/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-24 00:00:00 +0900", "snippet": "메세지 방식 propertiesdev.version=1.0.0 HTML&lt;!DOCTYPE HTML&gt;&lt;html&gt; ... &lt;p th:text=\"Version is #{dev.version}\"&gt;&lt;/p&gt; ...&lt;/html&gt; 결과Version is 1.0.0​" }, { "title": "Spring Security 패스워드 암호화", "url": "/posts/Spring-Security-%EC%95%94%ED%98%B8%ED%99%94-%EA%B5%AC%ED%98%84/", "categories": "Spring Security", "tags": "", "date": "2022-03-24 00:00:00 +0900", "snippet": "패스워드 암호화 Encryptor public interface Encryptor { String encrypt(String origin); boolean isMatch(String origin, String hashed);} BCryptEncryptorpublic class BCryptEncryptor implements Encryptor {\t@Override\tpublic String encrypt(String origin) {\t\treturn BCrypt.hashpw(origin, BCrypt.gensalt());\t}\t\t@Override\tpublic boolean isMatch(String origin, String hashed) {\t\ttry {\t\t\treturn BCrypt.checkpw(origin, hashed);\t\t} catch (Exception e) {\t\t\treturn false;\t\t}\t}} WebSecurityConfigpublic class WebSecurityConfig {// Bean으로 등록 시 @Autowired를 통해 Encryptor 선언 시 자동으로 클래스 바인딩\t@Bean public Encryptor encryptor(){ return new BCryptEncryptor(); }}" }, { "title": "Spring Security 로그인 UI 구현", "url": "/posts/Spring-Security-%EB%A1%9C%EA%B7%B8%EC%9D%B8/", "categories": "Spring Security", "tags": "Spring Security, Thymeleaf", "date": "2022-03-24 00:00:00 +0900", "snippet": "로그인 UI 구현 html&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Spring Security 로그인 예제 &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:if=\"${param.error}\"&gt; 잘못된 ID 또는 비밀번호 입니다. &lt;/div&gt; &lt;div th:if=\"${param.logout}\"&gt; 로그아웃 되었습니다. &lt;/div&gt; &lt;--&gt;ht:action=\"@{/login}\"로 작성할 경우 csrf 토큰 생성이 필요 없다.&lt;/--&gt; &lt;form th:action=\"@{/login}\" method=\"post\"&gt; &lt;div&gt;&lt;label&gt; 아이디 : &lt;input type=\"text\" name=\"username\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;label&gt; 비밀번호: &lt;input type=\"password\" name=\"password\"/&gt; &lt;/label&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"로그인\"/&gt;&lt;/div&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;로그인 성공 시 html&lt;!DOCTYPE html&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"https://www.thymeleaf.org\" xmlns:sec=\"https://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"&gt; &lt;head&gt; &lt;title&gt;Hello World!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 th:inline=\"text\"&gt;Hello [[${#httpServletRequest.remoteUser}]]!&lt;/h1&gt; &lt;form th:action=\"@{/logout}\" method=\"post\"&gt; &lt;input type=\"submit\" value=\"Sign Out\"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;" }, { "title": "Spring Security 기본", "url": "/posts/Spring-Security-%EA%B8%B0%EB%B3%B8/", "categories": "Spring Security", "tags": "Spring Security", "date": "2022-03-24 00:00:00 +0900", "snippet": "개발환경 구축 gradleimplementation 'org.springframework.boot:spring-boot-starter-security'implementation 'org.springframework.security:spring-security-test'Config 구현 Config@Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\t@Override\tprotected void configure(HttpSecurity http) throws Exception {\t\thttp\t\t\t.authorizeRequests() \t // 인증이 필요없는 url 입력 (현재 root와 home 설정됨)\t\t\t\t.antMatchers(\"/\", \"/home\").permitAll()\t\t\t\t.anyRequest().authenticated()\t\t\t\t.and()\t\t\t.formLogin()\t\t\t\t.loginPage(\"/login\")\t\t\t\t.permitAll()\t\t\t\t.and()\t\t\t.logout()\t\t\t\t.permitAll();\t}} Service@Bean@Overridepublic UserDetailsService userDetailsService() {\tUserDetails user =\t\t User.withDefaultPasswordEncoder()\t\t\t.username(\"user\")\t\t\t.password(\"password\")\t\t\t.roles(\"USER\")\t\t\t.build();\treturn new InMemoryUserDetailsManager(user);}" }, { "title": "Spring Security에 JPA 연동", "url": "/posts/Spring-Security-JPA-%EC%97%B0%EB%8F%99/", "categories": "Spring Security", "tags": "", "date": "2022-03-24 00:00:00 +0900", "snippet": "JPA 연동 Entity @Entitypublic class Account { @Id @GeneratedValue private Long id; @Column(unique = true) private String username; private String password; private String role; public void encodePassword(Encryptor encryptor){ this.password = encryptor.encode(this.password); }} Service@Service@RequiredArgsConstructorpublic class AccountService implements UserDetailService { private final AccountRepository accountRepository; private final Encryptor encryptor; // Bean으로 등록되어 BCryptEncryptor 호출 @Override public UserDetails loadUserByUsername(String username) throws Exception{ final Account account = accountRepository.findByUsername(username); return Optional.ofNullable(account).map(userAccount::new) .orElseThrow(() -&gt; new Exception(username)); // Exception 보통 정의하여 사용 } @Transactional Public Account createNew(Account account){ account.encodePassword(passwordEncoder); return accoutnRepository.save(account); } @Transactional public Optional&lt;User&gt; findPwMatchUser(Account account) { return accoutnRepository.findByUsername(account.username) .map(u -&gt; u.isMatched(encryptor, userPw) ? u : null); }} Repository@Repositorypublic interface AccountRepository extends JpaRepository&lt;Account, Long&gt; { Optional&lt;Account&gt; findByUsername(String username);}" }, { "title": "소프트웨어 생명 주기 모델 종류", "url": "/posts/00002-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%AA%A8%EB%8D%B8/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-23 00:00:00 +0900", "snippet": "폭포수 모델 (Waterfall Model) 각 단계를 확실히 마무리 한 뒤 다음 단계로 이동 가장 오래된 모델 선형 순차적 모형 고전적 생명주기 모형 경험과 성공사례가 많음 단계별 정의와 산출물이 명확 요구사항 변경이 어려움타당성 검토 → 계획 → 요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수 순차적 접근 이해가 용이 관리가 편리 요구사항 변경이 어려움프로토타이핑 모델 (Prototyping Model) 고객이 요구한 기능을 프로토 타입으로 구현 고객의 피드백을 반영하여 만들어감 고객, 개발자에게 공동의 참조 모델을 제공 프로토타입은 구현 단계의 구현 골격 프로토타입 개발 요구분석 용이 타당성 검증 가능 프로토타입 폐기에 따른 비용 증가나선형 모델 (Spiral Model) 점진적으로 개발해 나가는 모델계획 및 정의 → 위험 분석 → 개발 → 고객 평가 위험분석, 반복 개발 위험성 감소 변경에 유연한 대처 단계 반복으로 관리 어려움반복적 모델 (Iteration Model) 구축 대상을 나눠 병렬로 개발 후 통합 반복적으로 개발하여 조금씩 완성하는 SDLC 모델 요구사항 일부분, 제품 일부분을 반복적으로 개발하여 완성 증분 방식으로 병행 개발 병행 개발로 일정 단축 가능 관리 비용 증가" }, { "title": "소프트웨어 생명 주기 모델 프로세스", "url": "/posts/00001-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0-%EB%AA%A8%EB%8D%B8-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/", "categories": "정보처리기사", "tags": "정보처리기사", "date": "2022-03-23 00:00:00 +0900", "snippet": "소프트웨어 생명 주기 모델 프로세스요구사항 분석 → 설계 → 구현 → 테스트 → 유지보수요구사항 분석 요구와 조건을 결정 기능과 제약 조건, 목표를 명확히 정의 기능 요구사항, 비기능 요구사항설계 기능 수행 방법을 논리적으로 결정 시스템 구조 설계 프로그램 설계 사용자 인터페이스 설계구현 실제 프로그램을 작성 프로그래밍 언어, 기법, 스타일, 순서를 결정 인터페이스 개발 자료 구조 개발 오류 처리테스트 예상과 실제 결과의 차이를 검사하고 평가 단위 테스트 통합 테스트 시스템 테스트 인수 테스트유지보수 시스템 인수 후 일어나는 활동 예방, 완전, 교정, 적응, 유지보수 " }, { "title": "Thymeleaf의 변수 방식", "url": "/posts/Thymeleaf-basic-1/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-22 00:00:00 +0900", "snippet": "변수방식 HTML&lt;!DOCTYPE HTML&gt;&lt;html&gt; ... &lt;p th:text=\"${text}\"&gt;&lt;/p&gt; ...&lt;/html&gt; Controller@RequestMapping(\"/\")@Controllerpublic class Controller { @RequestMapping(\"/test\"){ public String test(Model model){ model.setAttribute(\"text\", \"test String\"); return \"test\"; }} 결과test String위에 setAttribute한 text값이 표시된다." }, { "title": "Thymeleaf 기초", "url": "/posts/AboutThymeleaf/", "categories": "Thymeleaf", "tags": "Thymeleaf", "date": "2022-03-21 00:00:00 +0900", "snippet": "Thymeleaf란? 컨트롤러가 전달한 값을 동적으로 표시하기 위한 뷰 템플릿 (View Template)Dependency 추가implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'Thymeleaf의 기본형Thymeleaf의 사용법에는 4가지가 있다. 변수 방식 ${} 메세지 방식 #{} 객체 변수 방식 *{} 링크 방식 @{} " } ]
