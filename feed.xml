<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://asd123fdssal.github.io/</id><title>ARSUD</title><subtitle>공부 및 기록용 Github Pages.</subtitle> <updated>2022-03-26T00:50:16+09:00</updated> <author> <name>ByeongMin Choi</name> <uri>https://asd123fdssal.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://asd123fdssal.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko-KR" href="https://asd123fdssal.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 ByeongMin Choi </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Abstract Factory 패턴</title><link href="https://asd123fdssal.github.io/posts/00016-Abstract-Factory-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="Abstract Factory 패턴" /><published>2022-03-25T13:45:00+09:00</published> <updated>2022-03-25T13:45:00+09:00</updated> <id>https://asd123fdssal.github.io/posts/00016-Abstract-Factory-%ED%8C%A8%ED%84%B4/</id> <content src="https://asd123fdssal.github.io/posts/00016-Abstract-Factory-%ED%8C%A8%ED%84%B4/" /> <author> <name>ByeongMin Choi</name> </author> <category term="정보처리기사" /> <category term="디자인패턴" /> <summary> 구체적인 클래스에 의존하지 않고 연관, 의존적인 객체의 조합을 만드는 인터페이스를 제공 구체적인 구현은 Concrete Product 클래스에서 이루어짐 동일 주제의 다른 팩토리를 묶는다. 클래스 다이어그램 [^출처] 소스코드 public interface IButton { void Paint(); } public interface IGUIFactory { IBtton CreateButton(); } public class WinButton extends IButton { public void Paint() { // Paint the button Windows style } } public class OSXButton extends IB... </summary> </entry> <entry><title>Factory Method 패턴</title><link href="https://asd123fdssal.github.io/posts/00015-Factory-Method-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="Factory Method 패턴" /><published>2022-03-25T11:57:00+09:00</published> <updated>2022-03-25T11:57:00+09:00</updated> <id>https://asd123fdssal.github.io/posts/00015-Factory-Method-%ED%8C%A8%ED%84%B4/</id> <content src="https://asd123fdssal.github.io/posts/00015-Factory-Method-%ED%8C%A8%ED%84%B4/" /> <author> <name>ByeongMin Choi</name> </author> <category term="정보처리기사" /> <category term="디자인패턴" /> <summary> 상위 클래스에서 객체를 생성하는 인터페이스 정의 (만드는 방법만 결정) 하위 클래스에서 인스턴스 생성 (실제 함수를 오버라이딩 하여 구현) 클래스 다이어그램 [^출처] 소스코드 public abstract class Room { abstract void connect(Room room); } public class MagicRoom extends Room { public void connect(Room room) {} } public class OrdinaryRoom extends Room { public void connect(Room room); } public abstract class MazeGame { private final List&amp;lt;R... </summary> </entry> <entry><title>Prototype 패턴</title><link href="https://asd123fdssal.github.io/posts/00014-Prototype-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="Prototype 패턴" /><published>2022-03-25T11:39:00+09:00</published> <updated>2022-03-25T11:39:00+09:00</updated> <id>https://asd123fdssal.github.io/posts/00014-Prototype-%ED%8C%A8%ED%84%B4/</id> <content src="https://asd123fdssal.github.io/posts/00014-Prototype-%ED%8C%A8%ED%84%B4/" /> <author> <name>ByeongMin Choi</name> </author> <category term="정보처리기사" /> <category term="디자인패턴" /> <summary> 일반적인 원형을 만든 뒤, 그것을 복사하여 필요한 부분만 수정하여 사용 객체의 원형을 제공하는 인스턴스에서 객체의 타입이 결정 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴 기존 객체를 복제함으로 생성 클래스 다이어그램 [^출처] 소스코드 // Prototype Class public class Cookie implements Cloneable { public Object clone() { try { Cookie copy = (Cookie)super.clone(); return copy; } catch(CloneNotSupportedException e... </summary> </entry> <entry><title>Builder 패턴</title><link href="https://asd123fdssal.github.io/posts/00013-Builder-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="Builder 패턴" /><published>2022-03-25T11:04:00+09:00</published> <updated>2022-03-25T14:03:04+09:00</updated> <id>https://asd123fdssal.github.io/posts/00013-Builder-%ED%8C%A8%ED%84%B4/</id> <content src="https://asd123fdssal.github.io/posts/00013-Builder-%ED%8C%A8%ED%84%B4/" /> <author> <name>ByeongMin Choi</name> </author> <category term="정보처리기사" /> <category term="디자인패턴" /> <summary> 복잡한 인스턴스를 조립하여 만드는 구조 복합 객체를 생성할 때 객체를 생성하는 방법과 구현하는 방법을 분리 동일 생성 절차로 다른 표현 결과를 만들 수 있음 클래스 다이어그램 [^출처] 소스코드 // Product @Setter class Pizza { private String dough = ""; private String sauce = ""; private String topping = ""; } // Abstract Builder @Getter abstrac class PizzaBuilder { protected Pizza pizza; public void createNewPizzaProduct() { pizza = ne... </summary> </entry> <entry><title>디자인 패턴 기초</title><link href="https://asd123fdssal.github.io/posts/00012-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="디자인 패턴 기초" /><published>2022-03-25T11:02:00+09:00</published> <updated>2022-03-25T11:23:20+09:00</updated> <id>https://asd123fdssal.github.io/posts/00012-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/</id> <content src="https://asd123fdssal.github.io/posts/00012-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/" /> <author> <name>ByeongMin Choi</name> </author> <category term="정보처리기사" /> <category term="디자인패턴" /> <summary> 디자인 패턴의 개념 소프트웨어 설계에서 공통으로 발생하는 문제 해결을 위하여 설계 방법을 정리한 패턴. 개발의 효율성, 유지보수성, 운용성이 높아지며 최적화에 도움이 됨 디자인 패턴의 종류 생성 패턴 Builder Prototype Factory Method Abstract Factory Singleton 구조패턴 Bridge Decorate Facade Flyweight Proxy Composite Adapter Mediator Interpreter 행위패턴 Itera... </summary> </entry> </feed>
